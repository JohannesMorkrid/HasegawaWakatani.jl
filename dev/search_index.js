var documenterSearchIndex = {"docs":
[{"location":"style guide/#Style-guide","page":"Style guide","title":"Style guide","text":"The following signatures should be followed","category":"section"},{"location":"style guide/#Order-of-problem-related-things","page":"Style guide","title":"Order of problem related things","text":"The first arguments should always be field/state related (du and u), then followed by  metadata/parameters, and time should always be last. As the Domain is more often used it  should be first in the case of meta data, followed by the parameters=p.\n\nIn-place: du, u, d, p, t\n\nOut-of-place: u, d, p, t\n\nIf prob::SpectralODEProblem is in use: u, prob, t¹\n\n¹Because the SpectralODEProblem stores the domain and parameters.","category":"section"},{"location":"style guide/#Exception-to-the-field/state-first","page":"Style guide","title":"Exception to the field/state first","text":"All arguments that are modified or related to the method goes first. For instance spectral_function(f::F, u::U, SC::SOC)","category":"section"},{"location":"style guide/#Order-during-construction","page":"Style guide","title":"Order during construction","text":"Should follow order of struct fields as close as possible. As for Bool flags, they should  be in the order of speed-up to the code or (?). In the case of domain that amounts to: use_cuda, precision, real_transform, dealiased","category":"section"},{"location":"style guide/#Order-of-other-arguments","page":"Style guide","title":"Order of other arguments","text":"Should follow order of struct construction and or order of struct fields.","category":"section"},{"location":"style guide/#Adding-TODOs","page":"Style guide","title":"Adding TODOs","text":"When wanting to add TODO comments, please also create a GitHub Issue  and add it to your TODO comment. Example\n\n# TODO add suitable test [#4](https://github.com/JohannesMorkrid/HasegawaWakatani.jl/issues/4)\nfunction example(...) = ...","category":"section"},{"location":"style guide/#DocStrings","page":"Style guide","title":"DocStrings","text":"Mainly follow the 11 steps outlined in the manual.  However emphasis should be put on separiting ## Positional Arguments and ## Keyword Arguments as done by SciML (example). Type should be included in the description instead of for the argument name.","category":"section"},{"location":"#Hasegawa-Wakatani-Project-Documentation","page":"Hasegawa Wakatani Project Documentation","title":"Hasegawa Wakatani Project Documentation","text":"Welcome to the documentation page. \n\nnote: Quick-Glimpse Tutorial\nThis tutorial just offered a quick glimpse on Julia's built-in documentation system, make sure to read the docs for more.\n\n<!–-Includes Domain, diagnostics, utilities, spectralSolve, spectralODEProblem and schemes –>","category":"section"},{"location":"#HasegawaWakatani.wave_vectors","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.wave_vectors","text":"wave_vectors(domain::Domain)\n\nReturn a tuple of wave vectors for each axis, default (ky, kx).\n\n\n\n\n\n","category":"function"},{"location":"#HasegawaWakatani.domain_kwargs","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.domain_kwargs","text":"domain_kwargs(domain::AbstractArray)\n\nReturn the domain specific keyword arguments, depending on the type of AbstractDomain.\n\n\n\n\n\n","category":"function"},{"location":"#HasegawaWakatani.area","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.area","text":"area(domain::AbstractDomain)\n\nCompute the area of the domain. By default use prod(lengths(domain)).\n\n\n\n\n\n","category":"function"},{"location":"#HasegawaWakatani.lengths","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.lengths","text":"lengths(domain::Domain)\n\nReturn a tuple of lengths for each axis, default (Ly, Lx).\n\n\n\n\n\n","category":"function"},{"location":"#HasegawaWakatani.Diagnostic-Tuple{Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.Diagnostic","text":"(diagnostic::Diagnostic)(state, prob, time)\n\nApply diagnostic method with the right args and kwargs stored in the Diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.Domain","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.Domain","text":"Two dimensional Domain assuming bi-spectral boundary conditions, equiped with transform_plans` for how to transform between physical and spectral 'space'.\n\nThe Domain struct is a collection of hints for how to construct the SpectralOperators used in the Linear and NonLinear right hand sides (rhs) used in the SpectralODEProblem. In addition the Domain store info about the wave_vectors associated with the Domain`.\n\nConstructors\n\nDomain(N; L=1, kwargs...)\n\nDomain(Nx, Ny; Lx=1, Ly=1,          MemoryType=Array,          precision=Float64,          real_transform=true,         dealiased=true,          x0=-Lx / 2, y0=-Ly / 2)\n\nPositional Arguments\n\nFor 'square' Domain specifically:\n\nN: number of points along both x- and y-direction (Integer).\n\nFor general 2D Domain specifically:\n\nNx: number of points along the x-direction (Integer).\nNy: number of points along the y-direction (Integer).\n\nKeyword Arguments\n\nFor 'square' Domain specifically:\n\nL: length of domain along both directions (Number).\n\nFor general 2D Domain specifically:\n\nLx: length of domain along the x-directions (Number).\nLy: length of domain along the y-directions (Number)\n\nGeneral keyword arguments\n\nMemoryType: memory Type used to store states, fields, spectral coefficients, etc., also used to configure transform plans. Array is used by default but all <:AbstractArray types should be supported as long as the corresponding MemoryType package is loaded.\nprecision: precision Type used in numerical calculations, also applies to precision of type and output. Defaults to Float64. Should be a numerical DataType.\nreal_transform: boolean flag to tell the program whether or not to use rfft and irfft methods to transform between physical and spectral space. This halves the number of spectral coefficient needed to be stored. Defaults to true.\ndealiased: whether or not to dealias the Pseudo spectral\n\nmethod. Defaults to true.\n\nx0: x-position of the lower left corner of the Domain. Defaults to x0 = -Lx  2.\ny0: y-position of the lower left corner of the Domain. Defaults to y0 = -Ly  2.\n\nExamples\n\njulia> Domain(128; L = 10, precision = Float32)\nDomain(Nx:128, Ny:128, Lx:10.0, Ly:10.0, real_transform:true, dealiased:true, MemoryType:Array{Float32}) offset by (-5.0, -5.0)\n\njulia> Domain(128, 256; Ly = 2, real_transform = true, x0 = 0, y0 = 10)\nDomain(Nx:128, Ny:256, Lx:1.0, Ly:2.0, real_transform:true, dealiased:true, MemoryType:Array{Float64}) offset by (0.0, 10.0)\n\nFields\n\ndx: spatial resolution/grid spacing, dx = 2Lx÷(Nx-1), in x-direction.\ndy: spatial resolution/grid spacing, dy = 2Ly÷(Nx-1), in y-direction.\nx: spatial position of each point along the x-axis. Uniformly distributed by default.\ny: spatial position of each point along the y-axis. Uniformly distributed by default.\nkx: wave vector components along x-axis.\nky: wave vector components along y-axis.\n\nwarning: Warning\nRestricted to 2D for the time being.\n\n\n\n\n\n","category":"type"},{"location":"#HasegawaWakatani.FFTPlans","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.FFTPlans","text":"FFTPlans{FT<:FFTW.Plan, iFT<:FFTW.Plan}\n\nCollection of transform plans using standard FFT.\n\n\n\n\n\n","category":"type"},{"location":"#HasegawaWakatani.NullParameters","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.NullParameters","text":"Nullparamters()\n\nSingleton to signalize that the user has not specified any parameters.\n\n\n\n\n\n","category":"type"},{"location":"#HasegawaWakatani.Output","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.Output","text":"Output{DV, U, UB, T, S, PT, K}\n\nA mutable struct for managing simulation output, diagnostics, and storage.\n\nFields\n\nstride::Int: Number of steps between stored samples.\ndiagnostics::DV: Array of Diagnostics.\nu::U: Array for storing simulation states in memory.\nstate_buffer::UB: Buffer for storing physical space state.\nt::T: Array for storing time points.\nsimulation::S: HDF5 group or Nothing, representing the simulation storage.\nphysical_transform::PT: Function to transform the state in physical space.\nstore_hdf::Bool: Whether to store output in HDF5 format.\nstore_locally::Bool: Whether to store output in memory.\ntransformed::Bool: Indicates if the state has been transformed to physical space.\nh5_kwargs::K: Named tuple of keyword arguments for HDF5 storage.\nresume::Bool: Whether to resume from an existing output file.\n\nConstructor\n\nOutput(prob::SOP; filename::FN, diagnostics::DV, stride::Integer, physical_transform::PT, simulation_name::SN, store_hdf::Bool, store_locally::Bool, storage_limit::AbstractString, h5_kwargs...)\n\nCreates an Output object for a given SpectralODEProblemprob`. Handles setup for HDF5 and local storage, initializes diagnostics, and manages sampling stride.\n\nKeyword Arguments\n\nfilename: Name of the HDF5 file for output (default: random temporary name).\ndiagnostics: Array of diagnostics to compute (default: DEFAULT_DIAGNOSTICS).\nstride: Number of steps between samples (default: -1 (lets the program decide)).\nphysical_transform: Function to transform state in physical space (default: identity).\nsimulation_name: Name for the simulation group in HDF5 (default: :timestamp).\nstore_hdf: Store output in HDF5 file (default: true).\nstore_locally: Store output in memory (default: true).\nstorage_limit: Limit for field storage (default: empty string).\nh5_kwargs...: Additional keyword arguments for HDF5 storage (merged with defaults).\nresume: Resume from existing output file (default: false).\n\nUsage\n\nCreate an Output object to manage simulation results, diagnostics, and storage options    for a given spectral ODE problem.\n\n\n\n\n\n","category":"type"},{"location":"#HasegawaWakatani.QuadraticTerm","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.QuadraticTerm","text":"\n\n\n\n","category":"type"},{"location":"#HasegawaWakatani.SpectralODEProblem","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.SpectralODEProblem","text":"SpectralODEProblem(L::Function, N::Function, u0, domain::AbstractDomain, tspan;\n    p=NullParameters(), dt=0.01, remove_modes::Function=remove_nothing, kwargs...)\nSpectralODEProblem(N::Function, u0, domain::AbstractDomain, tspan;\n    p=NullParameters(), dt=0.01, remove_modes::Function=remove_nothing, kwargs...)\n\nCollection of data needed to specify the spectral ODE problem to be solved. The user needs    to specify the non-linear operator N, with the linear operator L being optional and     otherwise assumed tp be zero. In addition the domain, initial condition u0 and    timespan tspan needs to be specified. The parameters p will be passed onto the     RHS/operators and the timestep dt is used by the temporal scheme. There is also the     option to add a method remove_modes to remove certain modes after each timestep. Other    kwargs can be stored in the struct, however these are currently unused.\n\n\n\n\n\n","category":"type"},{"location":"#HasegawaWakatani.rFFTPlans","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.rFFTPlans","text":"rFFTPlans{FT<:FFTW.Plan, iFT<:FFTW.Plan}\n\nCollection of transform plans using real FFT (rFFT), utilizing hermitian symmetry.\n\n\n\n\n\n","category":"type"},{"location":"#Base.show-Tuple{IO, HasegawaWakatani.AbstractTransformPlans}","page":"Hasegawa Wakatani Project Documentation","title":"Base.show","text":"Base.show(io::IO, transformplans::AbstractTransformPlans)\n\nPretty-print AbstractTransformPlans.\n\n\n\n\n\n","category":"method"},{"location":"#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, HasegawaWakatani.AbstractTransformPlans}","page":"Hasegawa Wakatani Project Documentation","title":"Base.show","text":"Base.show(io::IO, ::MIME\"text/plain\", transformplans::AbstractTransformPlans)\n\nCompact one-line show of AbstractTransformPlans for use in arrays and etc.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani._compute_radial_COM_velocity!-Tuple{Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani._compute_radial_COM_velocity!","text":"_compute_radial_COM_velocity!(memory, X_COM, time)\n\nCompute radial COM velocity based on current X_COM and previous memory positions.\n\n!!! warning   The memory Dict is altered to store the current state as the previous for next sample.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.add_h5_if_missing-Tuple{AbstractString}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.add_h5_if_missing","text":"add_h5_if_missing(filename::AbstractString)\n\nMakes sure the filename has an extension, if not the .h5 extension is added. \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.allocate_coefficients-Tuple{Any, Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.allocate_coefficients","text":"allocate_coefficients(u0, transformplans::AbstractTransformPlans)\n\nRecursively iterates trough the initial condition data structure to try to get to the    lowest level Array and then allocates the needed shape after applying the fwd transform.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.area-Tuple{HasegawaWakatani.AbstractDomain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.area","text":"area(domain::AbstractDomain)\n\nCompute the area of the domain. By default use prod(lengths(domain)).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.assert_no_nan-Tuple{AbstractArray, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.assert_no_nan","text":"assert_no_nan(u::AbstractArray, t)\nassert_no_nan(u::AbstractGPUArray, t)\n\nChecks if the first entry in u is NaN, if so a breakdown occured and an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.build_probe_diagnostic-Tuple{}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.build_probe_diagnostic","text":"build_probe_diagnostic(; name, method, positions, domain, quantities, \nassumes_spectral_state=false, interpolation)\n\nGeneral build method for probe diagnostics which prepares the positions and metadata.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.cfl","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.cfl","text":"cfl(state, prob, time, velocity=Val(:ExB), component=Val(:x); silent=false)\n\nCompute CFL based on which velocity and what component, if silent=false then the    results are printed. \n\nSee compute_velocity and compute_cfl for available options for    velocity and component respectively.  \n\nReturn\n\nArray where row represent the component and the first column is the max cfl, with the   remaining columns being indices.\n\n\n\n\n\n","category":"function"},{"location":"#HasegawaWakatani.check_if_output_file_exists_and_resume_is_false-Tuple{HDF5.Group, Bool}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.check_if_output_file_exists_and_resume_is_false","text":"check_if_output_file_exists(simulation::HDF5.Group, resume::Bool)\n\nChecks if the output file already exists when not resuming a previous simulation. If it    exists, the user is prompted to confirm overwriting the file.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.check_storage_size-Tuple{Int64, Int64, Int64, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.check_storage_size","text":"check_storage_size(storage_limit::Int, N_steps::Int, stride::Int, sample; context=\"\")\n\nChecks that the needed storage does not exceed the storage_limit, otherwise an error is    thrown, which recommends the minimum divisor satisfying the storage limit. In addition the    error checks of recommend_stride are performed, which may trigger before the storage check.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.compute_cfl-Tuple{Tuple, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.compute_cfl","text":"compute_cfl(velocities::Tuple, prob, time; component::Symbol=:x)\n\nCompute CFL-criterion for each velocity, based on which component is requested.\n\ncomponent options\n\n:x or :radial: return v_x*dt/dx.\n:y or :poloidal: return v_y*dt/dy.\n:both: return both :x and :y components.\n:magnitude: return hypot(vx, vy, ...)*dt/hypot(dx, dy, ...).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.compute_number_of_steps-Tuple{SpectralODEProblem}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.compute_number_of_steps","text":"compute_number_of_steps(prob::SpectralODEProblem)\n\nComputes the number of time steps the integrator needs to solve the problem prob. The    last step might be fractional and is therefore rounded up due to the fixed prob.dt.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.compute_radial_COM_position-Tuple{Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.compute_radial_COM_position","text":"compute_radial_COM_position(field, prob, time)\n\nCompute radial COM position for field (n) X_COM = ∑nx/∑n, excluding the boundary.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.compute_storage_need-Tuple{Int64, Int64, AbstractArray}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.compute_storage_need","text":"compute_storage_need(N_steps::Int, stride::Int, sample::AbstractArray; context=\"\")\n\nComputes the storage needed to store N_steps÷stridesamples with sizeof(sample). \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.compute_velocity-Tuple{Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.compute_velocity","text":"compute_velocity(state, prob, time, velocity::Symbol=:ExB)\n\nCompute the velocity fields, i.e. (vx, vy), based on velocity method.\n\nvelocity options:\n\n:ExB: uses (-∂ϕ∂y, ∂ϕ∂x)\n:burger: uses the state as the velocity magnitude.\n\nReturn\n\nTuple (vx, vy).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.construct_transform_plans-Tuple{Any, Type{Domain}, Val{true}}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.construct_transform_plans","text":"construct_transform_plans(utmp, ::Type{Domain}, ::Val{false})\nconstruct_transform_plans(utmp, ::Type{Domain}, ::Val{true})\n\nConstructs transform plans based on Domain type and if Real or Complex valued fields.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.create_or_open_group-Tuple{Union{HDF5.File, HDF5.Group}, AbstractString}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.create_or_open_group","text":"create_or_open_group(parent::Union{HDF5.File,HDF5.Group}, path::AbstractString; properties...)\n\nCreates or opens an HDF5 group at the specified path within the given parent (which can    be an HDF5.File or HDF5.Group). If the group at path exists, it is opened using    open_group; otherwise, a new group is created using create_group. Additional keyword    arguments (properties...) are passed onto the group creation or opening functions.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.determine_sampling_strategy-Tuple{Any, Int64, Any, SpectralODEProblem}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.determine_sampling_strategy","text":"prepare_sampling(stride::Int, storage_limit, prob::SpectralODEProblem)\n\nPrepares the sampling strategy for storing simulation states based on the desired stride    and storage limit. Determines the number of samples to store and the stride between samples.\n\nArguments\n\nstride::Int: The proposed stride between samples. If set to -1, the function \n\nwill automatically recommend an appropriate stride based on the storage limit.\n\nstorage_limit: The maximum allowed storage size for the output of fields, as a \n\nstring (e.g., \"100 MB\"). The limit does not affect the storage size of the Diagnostics!    If empty, no storage constraint is applied.\n\nprob::SpectralODEProblem: The SpectralODEProblem` containing the size of the fields.\n\nNotes\n\nIf both stride and storage_limit are unspecified, all steps are recorded.\nThe function validates and adjusts stride to ensure it is within feasible bounds.\nIssues a warning if the last step has a different stride than the rest.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.determine_strides-Tuple{Any, SpectralODEProblem, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.determine_strides","text":"\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.differential_area-Tuple{HasegawaWakatani.AbstractDomain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.differential_area","text":"differential_area(domain::AbstractDomain)\n\nCompute the differential area of the domain. By default use prod(differential_area(domain)).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.differential_elements-Tuple{Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.differential_elements","text":"differential_elements()\n\nReturn a tuple of differential elements, the grid spacing along each axis, default (dy, dx).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.domain_kwargs-Tuple{Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.domain_kwargs","text":"domain_kwargs(domain::AbstractArray)\n\nReturn the domain specific keyword arguments, depending on the type of AbstractDomain.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.energy_spectrum-Tuple{AbstractArray, Any, Any, Val{:radial}}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.energy_spectrum","text":"energy_spectrum(power_spectrum::AbstractArray, prob, time, ::Val{spectrum})\n\nComputes the energy spectrum E(k), based on the spectrum argument.\n\nspectrum options:\n\n:radial: radial (kx) spectrum, averaged over the poloidal direction.\n:poloidal: poloidal (ky) spectrum, averaged over the radial direction. \n:wavenumber: wavenumber (k) spectrum, averaged over wavenumber magnitude |k|.\n\nReturns:\n\n(wavenumbers, E) where E = E(k) (`Tuple`).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.ensure_in_domain-Tuple{Tuple{Number, Number}, Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.ensure_in_domain","text":"ensure_in_domain(position, domain::Domain)\n\nChecks if the position is inside the domain. Throws error if not.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.format_bytes-Tuple{Integer}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.format_bytes","text":"format_bytes(nbytes::Integer)\n\nFormats the number of bytes into a \"human readable\" format. For example: 1032 ⇒ \"1.03 KB\".\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.frequencies-Tuple{AbstractArray}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.frequencies","text":"frequencies(state)\n\nDisplays a heatmap of the mode-amplitudes in logscale.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.get_index-Tuple{Tuple{Number, Number}, HasegawaWakatani.AbstractDomain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.get_index","text":"get_index(position, domain)\n\nReturn Tuple of indices, the closest index for each dimension.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.get_labels-Tuple{Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.get_labels","text":"get_label(domain::Domain)\n\nReturn a tuple of labels (Symbols) for each axis, default (:y, :x).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.get_log_modes-Tuple{Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.get_log_modes","text":"get_log_modes(state_hat, prob, time; axis::Symbol=:diag)\n\nReturn log(|state_hat|) along an axis. See get_modes for the axis options.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.get_modes-Tuple{AbstractArray, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.get_modes","text":"get_modes(state_hat, prob, time; axis::Symbol=:both)\n\nReturn state_hat, along an axis.\n\naxis options (Symbol):\n\nkx: gets modes along the kx axis in spectral space.\nky: gets modes along the ky axis in spectral space.\nboth: gets all the modes in spectral space.\nkx: gets modes along the kx=ky line in spectral space. \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.get_points-Tuple{Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.get_points","text":"get_points(domain::Domain)\n\nReturn a tuple of points along each axis, default (y, x).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.handle_output!-Union{Tuple{N}, Tuple{SOP}, Tuple{T}, Tuple{O}, Tuple{O, Integer, T, SOP, N}} where {O<:Output, T<:AbstractArray, SOP<:SpectralODEProblem, N<:Number}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.handle_output!","text":"handle_output!(output::O, step::Integer, u::T, prob::SOP, t::N)\n\nHandles output operations for a simulation step, including state storage, diagnostics    sampling, and mode removal. Ensures the spectral state is only transformed once per step.    In addition a check is performed to detect breakdowns, to throw an error. \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.handle_simulation_name-Tuple{Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.handle_simulation_name","text":"handle_simulation_name(simulation_name)\n\nCreates a simulation_name string based on the users input. \n\nSupported symbols:\n\n:filename creates a string with the basename of the file without the extension.\n:timestamp creates a timestamp string using Dates.now().\n:parameters creates a string with the parameter names and values.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.initialize_diagnostics-Tuple{SpectralODEProblem, Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.initialize_diagnostics","text":"initialize_diagnostics(prob, state, state_hat, t0)\n\nBuild diagnostics from prob.diagnostic_recipes and sample.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.isinplace-Union{Tuple{HasegawaWakatani.AbstractODEProblem{iip}}, Tuple{iip}} where iip","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.isinplace","text":"isinplace(prob::AbstractODEProblem{iip}) where {iip}\nisinplace(f::Function)\nisinplace(L::Function, N::Function)\n\nChecks whether or not the functions are in place. Works like a trait.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.kinetic_energy_spectrum","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.kinetic_energy_spectrum","text":"kinetic_energy_spectrum(state_hat, prob, time, spectrum=Val(:radial))\n\nComputes energy spectrum of the kinetic power spectrum |̂Ω(k)|², based on spectrum type.\n\nSee energy_spectrum for spectrum type options.\n\n\n\n\n\n","category":"function"},{"location":"#HasegawaWakatani.lengths-Tuple{Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.lengths","text":"lengths(domain::Domain)\n\nReturn a tuple of lengths for each axis, default (Ly, Lx).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.maybe_sample_diagnostics!-Tuple{Any, Integer, Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.maybe_sample_diagnostics!","text":"maybe_sample_diagnostics!(output, step::Integer, u, prob, t)\n\nIterates through the list of diagnostics (output.diagnostics) and determines whether or   not to sample the diagnostic.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.nearest_divisor-Tuple{Int64, Int64}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.nearest_divisor","text":"nearest_divisor(N::Int, target::Int)\n\nFinds the nearest divisor of N to the target. If N is prime 1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.next_divisor-Tuple{Int64, Int64}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.next_divisor","text":"next_divisor(N, target)\n\nFinds the smallest divisor of N that is ≥ target. If none exists (i.e. target > N), N is returned.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.pad_size-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.pad_size","text":"pad_size(Ns::NTuple{N,Int})\n\nComputes the zero-pad size for the size Tuple Ns following the 3/2 rule.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.parameter_string-Tuple{P} where P<:AbstractDict","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.parameter_string","text":"parameter_string(parameters::AbstractDict)\nparameter_string(parameters::AbstractDict)\n\nCreates a human readable string listing the parameters with values, for example:    (κ=0.1,σ=0.02) ⇒ \"κ=0.1, σ=0.02\".\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.parse_diagnostic_expr-Tuple{Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.parse_diagnostic_expr","text":"Allows for single method()\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.parse_storage_limit-Tuple{Integer}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.parse_storage_limit","text":"parse_storage_limit(limit::Integer)\nparse_storage_limit(limit::AbstractString)\n\nParses a storage limit specified either as an integer (number of bytes) or as a string with    optional units (defaults to B). Supports both decimal and binary units up to \"EiB\", with a    decimal number of bytes. For example: \"10MB\", \"5.2 GiB\", \"1024\".\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.physical_flux-Union{Tuple{T}, Tuple{T, T, Any}} where T<:AbstractArray","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.physical_flux","text":"physical_flux(n_hat::T, dϕ_hat::T, domain)\n\nCompute the flux in physical space given a 'spectal gradient' of ϕ and the spectral n.   Dispatches on AbstractArray type T to differentiate between CPU and GPU.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.poloidal_flux-Tuple{GPUArraysCore.AbstractGPUArray, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.poloidal_flux","text":"poloidal_flux(state_hat, prob, time)\n\nComputes Γ0(t) = 1/(LxLy)∫0^Lx∫0^Ly nvy dydx, does not take into acount dealiasing.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.potential_energy_spectrum","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.potential_energy_spectrum","text":"potential_energy_spectrum(state_hat, prob, time, spectrum=Val(:radial))\n\nComputes energy spectrum of the potential power spectrum |̂n(k)|², based on spectrum type.\n\nSee energy_spectrum for spectrum type options.\n\n\n\n\n\n","category":"function"},{"location":"#HasegawaWakatani.prepare_functions-Tuple{Function, Function, NamedTuple}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.prepare_functions","text":"\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.prepare_indices-Tuple{Any, Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.prepare_indices","text":"prepare_indices(positions, domain::Domain)\n\nPrepare an Array of LinearIndices related to the fields on the domain, for quicker   parallel access.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.prepare_initial_condition-Tuple{Any, Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.prepare_initial_condition","text":"\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.prepare_initial_state-Tuple{Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.prepare_initial_state","text":"prepare_initial_state(prob; physical_transform=identity)\n\nPrepares the initial state by applying the user defined physical_transform, if any, to    a copy of the initial condition stored in prob, returning it alongside the initial time. \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.prepare_metadata-Tuple{AbstractArray{<:Tuple}, AbstractArray}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.prepare_metadata","text":"prepare_metadata(; positions::AbstractArray{<:Tuple}, quantities::String)\nprepare_metadata(; positions::AbstractArray{<:Tuple}, quantities::AbstractArray{<:String})\n\nPrepare a human readable overview of positions of probes and what is measured.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.prepare_operator_recipes-Tuple{Symbol, Vector{<:OperatorRecipe}, Vector{<:HasegawaWakatani.DiagnosticRecipe}}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.prepare_operator_recipes","text":"prepare_operator_recipes(operators::Symbol,\n                              additional_operators::Vector{<:OperatorRecipe},\n                              diagnostics::Vector{<:DiagnosticRecipe})\n\nUse switches to get a list of OperatorRecipes and append the additional_operators and   required_operators by the diagnostics to it.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.prepare_positions-Tuple{Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.prepare_positions","text":"prepare_positions(positions, domain)\n\nConvert positions into an Array{<:Tuples}, and check if the positions are in the domain. \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.prepare_spectral_coefficients-Tuple{Any, Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.prepare_spectral_coefficients","text":"\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.prepare_transform_plans-NTuple{5, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.prepare_transform_plans","text":"prepare_transform_plans(Nx, Ny, use_cuda, precision, real_transform)\n\nPrepare transform plan by preparing a domain using dispatching to call the right construction method.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.print_cfl-Tuple{Tuple, Any, Any, Union{Val{:x}, Val{:radial}}}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.print_cfl","text":"print_cfl(maximas::Tuple, prob, time, component::Val{Symbol})\n\nPrint the max CFL number alongside index and time in a human readable format.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.probe_all-NTuple{4, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.probe_all","text":"probe_all(state, prob, time; positions, interpolation=nothing)\n\nProbe the density (n), vorticity (Ω), potential (ϕ), radial velocity field (vᵣ) and    radial flux (Γ), at the given positions all \"at once\". \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.probe_density-NTuple{4, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.probe_density","text":"probe_density(state, prob, time; positions, interpolation=nothing)\n\nProbe the density field, n, at the given positions. \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.probe_field","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.probe_field","text":"probe_field(field::AbstractArray, domain::AbstractDomain, positions::AbstractArray,\n                 interpolation::Nothing=nothing)\nprobe_field(field::AbstractArray, domain::AbstractDomain, positions::AbstractArray,\n                 interpolation::AbstractInterpolation)\n\nProbe the field at multiple positions using the domain to determine the indices.    The method is dispatched on the interpolation method.\n\n\n\n\n\n","category":"function"},{"location":"#HasegawaWakatani.probe_field-Tuple{AbstractArray, HasegawaWakatani.AbstractDomain, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.probe_field","text":"probe_field(field::AbstractArray, domain::AbstractDomain, position::Tuple)\nprobe_field(field::AbstractInterpolation, domain::AbstractDomain, position::Tuple)\n\nProbe the field at one position using the domain to determine the index.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.probe_potential-NTuple{4, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.probe_potential","text":"probe_potential(state, prob, time; positions, interpolation=nothing)\n\nProbe the potential field, ϕ, at the given positions. \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.probe_radial_velocity-NTuple{4, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.probe_radial_velocity","text":"probe_radial_velocity(state, prob, time; positions, interpolation=nothing)\n\nProbe the radial velocity field, vᵣ, at the given positions. \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.probe_vorticity-NTuple{4, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.probe_vorticity","text":"probe_vorticity(state, prob, time; positions, interpolation=nothing)\n\nProbe the vorticity field, Ω, at the given positions. \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.progress-NTuple{4, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.progress","text":"progress_bar(state, prob, time, progress; t0, dt)\n\nUpdate `progress_bar` (`Progress` type from `ProgressMeter`.jl) based on evolution `time`.\n\n### Keyword arguments:\n- `t0`: start time (Number)\n- `dt`: timestep (Number)\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.radial_COM","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.radial_COM","text":"radial_COM(state, prob, time, memory=Dict(); field_idx::Int = 1)\n\nCompute the radial position X_COM and velocity V_COM as long as memory is passed.\n\nReturns\n\nArray where first column/entry is the position and the second is the velocity.\n\n\n\n\n\n","category":"function"},{"location":"#HasegawaWakatani.radial_flux-Tuple{GPUArraysCore.AbstractGPUArray, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.radial_flux","text":"radial_flux(state_hat, prob, time)\n\nComputes Γ0(t) = 1/(LxLy)∫0^Lx∫0^Ly nvx dydx, does not take into acount dealiasing.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.recommend_stride-Tuple{Int64, Int64, AbstractArray}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.recommend_stride","text":"recommend_stride(storage_limit::Int, N_steps::Int, sample::AbstractArray; context=\"\")\n\nRecommends the closest divisor to the minimum stride needed to fullfil the storage_limit.   If the storage_limit is too strict an error is thrown, which informs the user of the    minimum limit.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.restore_checkpoint-Union{Tuple{SA}, Tuple{SOP}, Tuple{HDF5.Group, SOP, SA}} where {SOP<:SpectralODEProblem, SA<:HasegawaWakatani.AbstractODEAlgorithm}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.restore_checkpoint","text":"restore_checkpoint(simulation::HDF5.Group, prob::SOP, scheme::SA) where {\nSOP<:SpectralODEProblem,SA<:AbstractODEAlgorithm}\n\nRestores Cache for scheme from checkpoint stored in simulation.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.rewrite_dataset-Tuple{Union{HDF5.File, HDF5.Group}, AbstractString, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.rewrite_dataset","text":"rewrite_dataset(parent::Union{HDF5.File,HDF5.Group}, name::AbstractString, data; pv...)\n\nDeletes the dataset if it allready exists and creates and writes to a new dataset.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.sample_diagnostic!-Tuple{Any, Any, Integer, Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.sample_diagnostic!","text":"TODO write actuall string: The spectral state u is transformed to the real   state U, with the user defined physical_transform applied, before being stored.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.save_checkpoint!-Union{Tuple{N}, Tuple{C}, Tuple{O}, Tuple{O, C, Integer, N}} where {O<:Output, C<:HasegawaWakatani.AbstractCache, N<:Number}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.save_checkpoint!","text":"save_checkpoint!(output::O, cache::C, step::Integer, t::N) where {O<:Output,\nC<:AbstractCache,N<:Number}\n\nCreates or opens a checkpoint and stors the cacheat time t corresponding to step=step.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.setup_diagnostic_group-NTuple{5, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.setup_diagnostic_group","text":"setup_simulation_group(file, simulation_name, N_samples, state, prob, t0; h5_kwargs)\n\nCreates a HDF5 group with simulation_name (a \"simulation\"), and allocates the correct    sizes based on N_samples with the fields being chunked with additinal h5_kwargs applied.   In addition the inital condition is written along with the attributes of the prob.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.setup_local_storage-Tuple{Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.setup_local_storage","text":"setup_local_storage(state, t0, N_samples; store_locally=store_locally)\n\nAllocates vectors in memory for storing the fields alongside the time if the user wants it,   otherwise empty vectors are returned.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.setup_simulation_group-Tuple{Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.setup_simulation_group","text":"setup_hdf5_storage(filename, simulation_name, N_samples::Int, state, prob, t0;\nstore_hdf=store_hdf, h5_kwargs=h5_kwargs)\n\nCreates a HDF5 file, if not existing, and writes a group with simulation_name to it,    refered to as a simulation group. If the simulation group does not exists, the h5_kwargs    are applied to the \"fields\" and \"t\" datasets. The opened simulation is returned.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.spectral_length-Tuple{HasegawaWakatani.AbstractDomain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.spectral_length","text":"spectral_length(domain::AbstractDomain)\n\nReturn the number of spectral coefficients. (length in spectral space).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.spectral_size-Tuple{HasegawaWakatani.AbstractDomain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.spectral_size","text":"spectral_size(domain::AbstractDomain)\n\nReturn a tuple containing the size of the spectral coefficient Array (size in spectral space).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.spectral_transform!-Union{Tuple{P}, Tuple{Any, P, Any}} where P<:AbstractFFTs.Plan","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.spectral_transform!","text":"spectral_transform!(U<:AbstractArray, transformplan<:FFTW.Plan)\nspectral_transform!(U<:Union{Tuple,Vector}, transformplan<:FFTW.Plan)\n\nSpectral transform, applies transform plan p to u in-place returning du.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.spectral_transform-Union{Tuple{P}, Tuple{T}, Tuple{T, P}} where {T<:AbstractArray, P<:AbstractFFTs.Plan}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.spectral_transform","text":"spectral_transform(U<:AbstractArray, transformplan<:FFTW.Plan)\nspectral_transform(U<:Union{Tuple,Vector}, transformplan<:FFTW.Plan)\n\nSpectral transform out-of-place, applies transform plan p to U. \n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.store_checkpoint!-Union{Tuple{N}, Tuple{C}, Tuple{G}, Tuple{G, C, Integer, N}} where {G<:HDF5.Group, C<:HasegawaWakatani.AbstractCache, N<:Number}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.store_checkpoint!","text":"store_checkpoint!(checkpoint::G, cache::C, step::Integer, t::N) where {G<:HDF5.Group,\nC<:AbstractCache,N<:Number}\n\nStores checkpoint by dumping the fields of the cache that are not of type    AbstractTableau. This overwrites the previously stored checkpoint.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.store_diagnostic!-Tuple{Any, Any, Integer, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.store_diagnostic!","text":"store_diagnostic!(output, step::Integer, sample, time)\n\nStores sample to HDF5 file and memory, depending on the state of the output.store_hdf    and output.store_locally respectively. The index is computed based on the step.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.transform_state!-Tuple{Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.transform_state!","text":"transform_state!(output, u, p)\n\nTransforms spectral coefficients u_hat into real fields by applying spectral_transform!    to the output.state_buffer buffer. The user defined physical_transform is also applied to    the buffer, and the output.transformed flag is updated to not transform same field twice.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.validate_positions-Tuple{Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.validate_positions","text":"validate_positions(positions, domain)\n\nCheck that all points have the correct length and are within the bounds of the domain.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.validate_stride-Tuple{Int64, Int64}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.validate_stride","text":"validate_stride(N_steps::Int, stride::Int; context=\"\")\n\nValidates and adjusts the `stride`. If `stride`:\n\nexceeds N_steps, it is set to N_steps and a warning is issued.\nis less than 1 an ArgumentError is thrown.\ndoes not evenly divide N_steps, a warning is issued and a suggested divisor is provided.\n\nReturns the validated (and possibly adjusted) stride.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.wave_vectors-Tuple{Domain}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.wave_vectors","text":"wave_vectors(domain::Domain)\n\nReturn a tuple of wave vectors for each axis, default (ky, kx).\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.wavenumber_metadata-Tuple{Val{:radial}}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.wavenumber_metadata","text":"wavenumber_metadata(::Val{spectrum}) where spectrum<:Symbol\n\nReturn human readable metadata about which wavenumber is stored.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.write_attributes-Tuple{Any, SpectralODEProblem}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.write_attributes","text":"write_attributes(simulation, prob::SpectralODEProblem)\nwrite_attributes(simulation, domain::AbstractDomain)\n\nWrites the esential attributes of the container to the simulation group simulation. The    SpectralODEProblem also writes the domain properties.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.write_local_state-Tuple{Output, Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.write_local_state","text":"write_local_state(output, idx, u, t)\n\nWrites the state u at time t to the local storage in the Output struct.\n\n\n\n\n\n","category":"method"},{"location":"#HasegawaWakatani.write_to-Tuple{HDF5.Group, Any, Any, Any}","page":"Hasegawa Wakatani Project Documentation","title":"HasegawaWakatani.write_to","text":"write_to(h5group::HDF5.Group, idx, data, time)\n\nWrites the data at time time to the  h5group (HDF5).\n\n\n\n\n\n","category":"method"}]
}
